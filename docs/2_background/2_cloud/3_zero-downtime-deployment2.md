---
layout: default
title: "ZD deployment2(김승용)"
parent: "cloud"
grand_parent: "background"
nav_order: 3
# permalink: "docs/background/backend/dependency-injection"
---
## Zero Downtime Deployment(무중단 배포) 실제 사례

## Marcin Grzejszcazk / May 31, 2016

####  https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database



#### Introduction



##### 무중단 배포

성공적인 무중단 배포란? 유저가 서비스가 멈추는 것을 알지 못한 채 새로운 버전과 기능이 적용되는 것.

무중단 배포 방법 중 하나는 아래와 같다.

1. 버전 1 배포
2. DB를 새 버전으로 마이그레이션
3. 버전 2와 버전 1을 병렬로 운영
4. 버전 2가 문제가 없다면 버전 1을 내린다.
5. 끝!

쉬워보이지만 그렇게 말처럼 쉬운게 아니다. 다른 유명한 배포 방법인 Blue-Green 배포를 살펴보자.

1. 두 개의 운영 환경을 준비한다.(Blue와 Green)
2. 모든 트래픽은 Blue 환경으로 라우팅되어 있다.
3. Green 환경에 새로운 어플리케이션을 배포, 적용한다.
4. "Flip the switch", 라우팅을 Green으로 변경하고 Blue와의 연결은 끊는다.

Blue-Green 배포는 운영환경에서 스트레스 없이 새로운 기능을 쉽게 배포할 수 있는 방법이다. 왜냐하면 문제가 생겼을 때 "Flip the switch"로 라우팅만 변경해서 쉽게 롤백할 수 있기 때문이다.

자원이 두배로 필요한데 왜 굳이 Blue-Green 배포를 해야만 하지? 라고 물을 수 있다. 이에 대해 Martin Fowler 옹은 아래와 같이 접근 방식에 변화를 주는 경향이 있다.

> 다른 방법은 하나의 똑같은 DB를 사용하고, Web와 Domain 영역에서만 Blue-Green Switch를 하는 것이다.
>
> DB는 스키마를 새로운 버전의 App과 호환시키려면 기술적으로 어려움이 있을 수 있다.

이 글에서 가장 중요하게 다룰 이슈는 **Database**이다. 다시 다음 문장을 봐보자.

> DB를 새로운 버전으로 마이그레이션

만약 DB 변경사항이 롤백이 불가능하다면? 어플리케이션 버전 1이 날아가버렸다면? 퇴사각?

그렇기에 무중단 배포 / blue-green deployment의 장접에도 불구하고 많은 기업들이 아래 프로세스를 하곤 한다.

1. 새 버전의 패키지 준비
2. 실행중인 어플리케이션 종료
3. DB 마이그레이션 스크립트 실행
4. 새 버전 어플리케이션 배포 및 실행

=> 현재 우리가 하고 있는 방식

이 글에서는 어떻게 DB와 코드를 다루어야 무중단 배포의 장점을 누릴 수 있는지에 대해 서술한다.



##### DB 이슈

적재된 데이터가 없다면 언제든 무중단 배포를 쉽게 할 수 있지만, 그런 경우는 거의 없기 때문에 DB 이슈가 발생한다. 이슈를 해결하기 위해 Schema Versioning을 먼저 생각해야한다.



##### Schema Versioning

이 Article에서는 Schema Versioning을 위해 Flyway라는 DB Schema 관리 툴을 사용한다. 스프링 부트 어플리케이션과 호환이 되는 툴.

```bash
└── db
 └── migration
     ├── V1__init.sql
     ├── V2__Add_surname.sql
     ├── V3__Final_migration.sql
     └── V4__Remove_lastname.sql
```

위 예시는 차례로 실행되는 DB 마이그레이션 예시이다.

첫 번째  V1__init.sql은 다음과 같다

```sql
CREATE TABLE PERSON (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY,
	first_name varchar(255) not null,
	last_name varchar(255) not null
);

insert into PERSON (first_name, last_name) values ('Dave', 'Syer');
```

SQL을 사용해서 어떻게 DB가 변경될 지 정의할 수 있다. Schema Versioning 툴을 사용하면, 다음의 두 가지 장점이 있다.

1. DB 변경과 코드 변경의 Decoupling을 할 수 있다.
2. DB 마이그레이션이 어플리케이션 배포와 동시에 진행될 수 있다. - 배포 프로세스가 더 간단해진다
   라는 장점이 있다.



------



#### DB 이슈 해결하기

'롤백 불가능'과 '롤백 가능'한 두 가지 DB 변경 케이스에 대해 생각해보자.

Person이라는 테이블이 있고 거기에 `first_name`과 `last_name`이라는 DB Column이 있다. `last_name`을 `surname`으로 Column 이름을 변경하는 걸 예시로 생각해보자.



##### 가정

- DB 롤백을 하고 싶지 않다.
  -> 그래야 배포가 간단해진다. 어플리케이션만 롤백을 하지, DB는 롤백을 하고 싶지 않다. 이렇게 하면 DB가 다르더라도(ex NoSQL, SQL), 같은 배포 파이프라인으로 보일 것이다.
- 하나 이전의 버전으로만 어플리케이션 롤백을 할 수 있고 싶다.
  -> 필요할 때만 롤백을 진행한다. 예를 들어, 현재 버전에 쉽게 고칠 수 없는 버그가 발생한 경우, 이전 버전으로 롤백을 진행할 수 있어야 한다. 한 개 이상의 배포에 대한 코드와 DB 호환성 유지하는 것은 어렵고 비용이 많이 든다.



------



#### Step 1. Initial State

##### App Version : 1.0.0

##### DB Version : v1

##### 코멘트

진행할 어플리케이션의 초기 상태



##### DB 변경사항

DB가 `last_name`이란 column을 가지고 있다.

```sql
CREATE TABLE PERSON (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY,
	first_name varchar(255) not null,
	last_name varchar(255) not null
);

insert into PERSON (first_name, last_name) values ('Dave', 'Syer');
```



##### 코드 변경사항

어플리케이션의 `Person` 데이터에 `last_name`이란 column이 있다.

```java
/*
 * Copyright 2012-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sample.flyway;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Person {
	@Id
	@GeneratedValue
	private Long id;
	private String firstName;
	private String lastName;

	public String getFirstName() {
		return this.firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return this.lastName;
	}

	public void setLastName(String lastname) {
		this.lastName = lastname;
	}

	@Override
	public String toString() {
		return "Person [firstName=" + this.firstName + ", lastName=" + this.lastName
				+ "]";
	}
}
```



------



#### 2-1. <u>복구 불가능한 방법으로의 Column 이름 변경</u>

##### App Version : 2.0.0 BAD

##### DB Version : v2bad

##### 코멘트

이 방법으로 진행하면 변경사항이 새 버전과 구 버전이 동시에 실행될 수 없다. 그렇기에 무중단 배포가 매우 중요함.

###### A/B testing

현재 상황은 버전 1.0.0 App과 v1 DB가 운영되는 상황. 앱의 두 번째 instance를 2.0.0 BAD로, DB를 v2bad로 업그레이드 하려고 한다.

###### 단계

1. App의 새 instance에 2.0.0 BAD를, DB에 v2bad를 배포한다.
2. v2bad의 Column `last_name`은 더이상 존재하지 않는다 - `surname`으로 변경 되었다.
3. DB와 App이 업그레이드 되었고 일부 instance는 1.0.0, 나머지는 2.0.0 BAD이며 DB는 전부 v2bad인 상황
4. 1.0.0의 모든 instance는 `last_name`에 데이터를 insert하려 하기 때문에 에러가 발생할 것이다.
5. 2.0.0 BAD 버전의 instance는 오류 없이 작동한다.

DB와 App 롤백이 불가능한 변경의 경우 A/B testing이 불가능하다.

###### App 롤백

1.0.0 버전으로 App을 롤백하고, DB는 롤백하지 않는 것을 가정해보자.

###### 단계

1.  2.0.0 BAD 버전의 instance를 종료한다.
2. DB는 계속 v2bad
3. 1.0.0버전이 `surname`을 모르기 때문에 에러가 발생
4. 개ㅈ망



##### DB 변경사항

Column `last_name`을 `surname`으로 변경한다.

```sql
ALTER TABLE PERSON CHANGE last_name surname VARCHAR;
```



##### 코드 변경사항

`lastName`을 `surname`으로 변경한다.



------



#### 2.2 <u>복구 가능한 방법으로의 Column이름 변경</u>

가장 빈번하게 마주하게 될 상황. 무중단 배포를 위해서는 추가 작업 없이 DB 마이그레이션을 간단하게 진행해서는 안된다는 것을 배웠다. 그렇기 때문에 복구가 가능한 DB 마이그레이션을 위한 3단계 배포를 알아보자.



#### Step2. Adding surname

##### App Version : 2.0.0

##### DB Version : v2

###### 코멘트

새로운 Column을 생성하고 그 안에 기존 내용을 복사하는 것으로 복구 가능한 DB 마이그레이션을 할 수 있다. 코드를 롤백하더라도 이전 버전이 호환되기 때문에 충돌나지 않는다.

###### 단계

1. DB에 `surname`이라는 새로운 컬럼을 추가한다. 이것이 v2 DB이다.
2. `last_name`에 있는 데이터를 `surname`에 복사한다. 만일 `last_name`에 너무 많은 데이터가 있다면 batch migration을 고려해야한다.
3. 코드에 새로운 Column과 기존 Column 두개 모두 작성한다. 이것이 App 2.0.0이다.
4. `surname` Column의 데이터가 null이 아니라면 `surname`을 통해서 데이터를 읽어본다. `surname`에 데이터가 아직 세팅되지 않았다면 `last_name` Column으로 데이터를 읽어본다. `getLastName()`은 이게 아무런 기능을 못할 때, 즉 다시 말해, 어플리케이션 버전이 3.0.0으로 올라가서 롤백 코드가 2.0.0일 때 지운다.

만약 Spring Boot Flyway를 사용하고 있다면 두 단계가 앱의 2.0.0 버전을 부팅할 때 수행된다? DB 버전 관리 툴을 하용하고 있다면 이렇게 굳이 단계를 나눌 필요는 없다.(매뉴얼하게 DB 버전을 업그레이드 한 이후에 새 어플리케이션을 배포한다.)

> 새로 추가된 Column은 Not Null이 아니어야만 한다. 데이터를 이관한 이후에 제약조건을 걸어야 한다.
>
> getLastName() 메소드는 버전 3.0.0에서는 `last_name`를 사용하지 않기 때문에 지워야 한다.



##### A/B testing

현재 상황은 App 1.0.0과 DB v1이 배포된 상황이며, App 2.0.0 instance를 배포하고 DB를 v2로 업그레이드 하려는 상황이다.

###### 단계

1. 버전 2.0.0 Instance가 배포되고 DB도 v2로 업데이트 된다.
2. 몇몇 request는 버전 1.0.0 instance에서 프로세스가 진행된다.
3. 업데이트가 완료됐으면 1.0.0 instance와 2.0.0 instance가 공존하며, DB는 전부 v2를 사용하고 있다.
4. 버전 1.0.0은 DB의 `surname` 컬럼을 사용하지 않고 버전 2.0.0은 `surname`을 사용한다. 하지만 그것은 상관없고 에러는 발생하지 않는다.
5. 원문이 오타인듯?
   DB v2는 기존 Column과 신규 Column에 모두 데이터를 저장하고 있고, 롤백이 가능하다.

> 기존 Column과 신규 Column의 값을 카운트해야 한다면, 데이터가 중복되었다는 것을 기억해야한다. 예를 들어, 성이 A로 시작하는 사람의 수를 카운트한다면, 기존 Column에서 신규 Column으로 데이터를 옮기기 전에는 데이터가 정확하지 않을 수 있다.



##### 어플리케이션 롤백

App 2.0.0, DB v2 상태에서 롤백하는 경우

###### 단계

1. App 1.0.0으로 롤백한다.
2. 버전 1.0.0은 `surname` Column을 사용하지 않기 때문에 롤백은 문제없이 수행된다.



##### DB 변경사항

DB는 `last_name`을 가지고 있다.

초기 Flyway script

```sql
CREATE TABLE PERSON (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY,
	first_name varchar(255) not null,
	last_name varchar(255) not null
);

insert into PERSON (first_name, last_name) values ('Dave', 'Syer');
```

`surname` Column을 추가

> NOT NULL 제약조건을 넣지 말아야 한다. 롤백할 경우 새 Column에는 NULL 값이 유지될 것이기 때문이다.

```sql
-- NOTE: This field can't have the NOT NULL constraint cause if you rollback, the old version won't know about this field
-- and will always set it to NULL
ALTER TABLE PERSON ADD surname varchar(255);

-- WE'RE ASSUMING THAT IT'S A FAST MIGRATION - OTHERWISE WE WOULD HAVE TO MIGRATE IN BATCHES
UPDATE PERSON SET PERSON.surname = PERSON.last_name
```



##### 코드 변경사항

`last_name`과 `surname` 양쪽에 데이터를 저장하며, `last_name`에서 값을 읽는다. 배포가 진행되는 동안 몇몇 request는 업데이트가 되지 않은 instance에서 프로세스된다.

```java
/*
 * Copyright 2012-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sample.flyway;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Person {
	@Id
	@GeneratedValue
	private Long id;
	private String firstName;
	private String lastName;
	private String surname;

	public String getFirstName() {
		return this.firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	/**
	 * Reading from the new column if it's set. If not the from the old one.
	 *
	 * When migrating from version 1.0.0 -> 2.0.0 this can lead to a possibility that some data in
	 * the surname column is not up to date (during the migration process lastName could have been updated).
	 * In this case one can run yet another migration script after all applications have been deployed in the
	 * new version to ensure that the surname field is updated.
	 *
	 * However it makes sense since when looking at the migration from 2.0.0 -> 3.0.0. In 3.0.0 we no longer
	 * have a notion of lastName at all - so we don't update that column. If we rollback from 3.0.0 -> 2.0.0 if we
	 * would be reading from lastName, then we would have very old data (since not a single datum was inserted
	 * to lastName in version 3.0.0).
	 */
	public String getSurname() {
		return this.surname != null ? this.surname : this.lastName;
	}

	/**
	 * Storing both FIRST_NAME and SURNAME entries
	 */
	public void setSurname(String surname) {
		this.lastName = surname;
		this.surname = surname;
	}

	@Override
	public String toString() {
		return "Person [firstName=" + this.firstName + ", lastName=" + this.lastName + ", surname=" + this.surname
				+ "]";
	}
}
```



------



#### Step 3. Removing last name from code

##### App Version : 3.0.0

##### DB Version : v3

###### 코멘트

새 Column을 추가하고 데이터를 복사하는 것으로 롤백 가능하게 만들었다. 지금은 롤백을 진행하건 구 버전 어플리케이션이 돌아가건 에러가 나지 않는다.



##### 어플리케이션 롤백

버전 3.0.0은 `last_name` 데이터를 저장하지 않는다. 즉, `surname`에 데이터가 저장된다.

###### 단계

1. 버전 2.0.0으로 어플리케이션을 롤백한다.
2. 버전 2.0.0은 `last_name`과 `surname` 모두 사용 중이다.
3. 버전 2.0.0은 우선적으로 `surname`의 데이터를 볼 것이고 이게 null이라면 `last_name`데이터를 볼 것이다.



##### DB 변경사항

DB 구조상 변경사항은 없다. 아래 스크립트는 기존 데이터의 최종 마이그레이션을 수행하는 것이다.

```sql
-- WE'RE ASSUMING THAT IT'S A FAST MIGRATION - OTHERWISE WE WOULD HAVE TO MIGRATE IN BATCHES
-- ALSO WE'RE NOT CHECKING IF WE'RE NOT OVERRIDING EXISTING ENTRIES. WE WOULD HAVE TO COMPARE
-- ENTRY VERSIONS TO ENSURE THAT IF THERE IS ALREADY AN ENTRY WITH A HIGHER VERSION NUMBER
-- WE WILL NOT OVERRIDE IT.
UPDATE PERSON SET PERSON.surname = PERSON.last_name;

-- DROPPING THE NOT NULL CONSTRAINT; OTHERWISE YOU WILL TRY TO INSERT NULL VALUE OF THE LAST_NAME
-- WITH A NOT_NULL CONSTRAINT.
ALTER TABLE PERSON MODIFY COLUMN last_name varchar(255) NULL DEFAULT NULL;
```



##### 코드 변경사항

`last_name`과 `surname` 양쪽 데이터 모두를 저장하고 있다. 아직 업데이트되지 않은 instance로 request 프로세스가 진행됐을 때의 가장 최신의 `last_name` Column을 읽는다.

```java
/*
 * Copyright 2012-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sample.flyway;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Person {
	@Id
	@GeneratedValue
	private Long id;
	private String firstName;
	private String surname;

	public String getFirstName() {
		return this.firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getSurname() {
		return this.surname;
	}

	public void setSurname(String lastname) {
		this.surname = lastname;
	}

	@Override
	public String toString() {
		return "Person [firstName=" + this.firstName + ", surname=" + this.surname
				+ "]";
	}
}
```



------



#### Step 4. Removing last name from DB

##### App Version : 4.0.0

##### DB Version : v4

###### 코멘트

버전 3.0.0에서는 `last_name` Column을 사용하지 않기 때문에, DB에서 `last_name`을 지우고 나서 3.0.0으로 롤백을 하더라도 아무 에러가 나지 않을 것이다.



##### Logs from script execution

```bash
We will do it in the following way:

01) Run 1.0.0
02) Wait for the app (1.0.0) to boot
03) Generate a person by calling POST localhost:9991/person to version 1.0.0
04) Run 2.0.0
05) Wait for the app (2.0.0) to boot
06) Generate a person by calling POST localhost:9991/person to version 1.0.0
07) Generate a person by calling POST localhost:9992/person to version 2.0.0
08) Kill app (1.0.0)
09) Run 3.0.0
10) Wait for the app (3.0.0) to boot
11) Generate a person by calling POST localhost:9992/person to version 2.0.0
12) Generate a person by calling POST localhost:9993/person to version 3.0.0
13) Kill app (3.0.0)
14) Run 4.0.0
15) Wait for the app (4.0.0) to boot
16) Generate a person by calling POST localhost:9993/person to version 3.0.0
17) Generate a person by calling POST localhost:9994/person to version 4.0.0


Starting app in version 1.0.0
Generate a person in version 1.0.0
Sending a post to 127.0.0.1:9991/person. This is the response:

{"firstName":"52b6e125-4a5c-429b-a47a-ef18bbc639d2","lastName":"52b6e125-4a5c-429b-a47a-ef18bbc639d2"}

Starting app in version 2.0.0

Generate a person in version 1.0.0
Sending a post to 127.0.0.1:9991/person. This is the response:

{"firstName":"e41ee756-4fa7-4737-b832-e28827a00deb","lastName":"e41ee756-4fa7-4737-b832-e28827a00deb"}

Generate a person in version 2.0.0
Sending a post to 127.0.0.1:9992/person. This is the response:

{"firstName":"0c1240f5-649a-4bc5-8aa9-cff855f3927f","lastName":"0c1240f5-649a-4bc5-8aa9-cff855f3927f","surname":"0c1240f5-649a-4bc5-8aa9-cff855f3927f"}

Killing app 1.0.0

Starting app in version 3.0.0

Generate a person in version 2.0.0
Sending a post to 127.0.0.1:9992/person. This is the response:
{"firstName":"74d84a9e-5f44-43b8-907c-148c6d26a71b","lastName":"74d84a9e-5f44-43b8-907c-148c6d26a71b","surname":"74d84a9e-5f44-43b8-907c-148c6d26a71b"}

Generate a person in version 3.0.0
Sending a post to 127.0.0.1:9993/person. This is the response:
{"firstName":"c6564dbe-9ab5-40ae-9077-8ae6668d5862","surname":"c6564dbe-9ab5-40ae-9077-8ae6668d5862"}

Killing app 2.0.0

Starting app in version 4.0.0

Generate a person in version 3.0.0
Sending a post to 127.0.0.1:9993/person. This is the response:

{"firstName":"cbe942fc-832e-45e9-a838-0fae25c10a51","surname":"cbe942fc-832e-45e9-a838-0fae25c10a51"}

Generate a person in version 4.0.0
Sending a post to 127.0.0.1:9994/person. This is the response:

{"firstName":"ff6857ce-9c41-413a-863e-358e2719bf88","surname":"ff6857ce-9c41-413a-863e-358e2719bf88"}
```



##### DB 변경사항

v3에서 `last_name` Column만 지운 뒤, 적용하지 않았던 제약조건을 적용한다.

```sql
-- REMOVE THE COLUMN
ALTER TABLE PERSON DROP last_name;

-- ADD CONSTRAINTS
UPDATE PERSON SET surname='' WHERE surname IS NULL;
ALTER TABLE PERSON ALTER COLUMN surname VARCHAR NOT NULL;
```



##### 코드 변경사항

코드 변경사항은 없다.



------



#### Recap

성공적으로 롤백 가능한 배포를 적용했다.

요약을 한다면 아래와 같다.

1. App 1.0.0 / DB v1
   초기상태 ( Column => `last_name` )
2. 데이터를 `last_name`과 `surname`에 저장하는 App 2.0.0을 배포한다. App은 `last_name` Column에서 데이터를 읽는다. DB v2는 `last_name`과 `surname` Column을 모두 가지고 있는다. `surname`은 `last_name`을 복제하여 만든다.( NOT NULL 제약조건이 있으면 안된다. )
3. 데이터를 `surname`에만 저장하고 `surname`에서만 읽는 App 3.0.0을 배포한다. `last_name`에서 `surname`으로의 최종 마이그레이션이 일어난다. `last_name`의 NOT NULL 제약조건을 드랍한다. DB 버전은 v3.
4. 버전 4.0.0을 배포한다. 코드에는 변화가 없다. `last_name`에서 `surname`으로의 최종 마이그가 수행됐고, `last_name`이 삭제된 DB v4를 배포한다. 적용하지 않았던 제약조건을 적용한다.

위 방법을 통해 롤백 가능한 DB / APP 배포가 가능하다.



본 웹페이지에 방문하면 Github 링크를 통해 Project와 Script를 확인할 수 있다.